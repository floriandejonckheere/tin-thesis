\chapter{Data model}
\label{ch:data-model}

In this chapter we describe the conceptual domain of the use case, and provide logical data models applied to the NoSQL data models selected in the previous chapter.
Physical data models for MongoDB, CouchDB and Neo4j will be presented, along with an implementation in a demo Ruby on Rails application using the available language bindings.
Finally, a set of reference queries that may typically be used in the context of the Recent Activity feed will be proposed.
These queries will be formally described, and subsequently implemented in the query languages specific to the three data stores.

\section{Domain description}
\label{sec:domain-description}

On the Open Webslides platform, no distinction is made between a teacher and a student in the data model.
Both are represented by the \texttt{User} entity in the database.
This entity contains information pertaining to the user, such as email address, first name and last name.
The data models described in the next sections will closely follow the existing data model of the platform.
However, attributes irrelevant to the Recent Activity feed are omitted from the model and not available in the NoSQL data store, in order to improve efficiency and simplify abstraction.

A user can create or modify course content in an interactive online editor.
The actual course content, formally called a topic, is stored inside a git repository on the filesystem.
However, the platform also maintains a record of topic metadata in the relational database.
This metadata includes title and description, but also permissions and contributors on the course content.

From a technical perspective, the user has three distinct paths of action for creation and co-creation on course content.
Since the permission model in the platform is not relevant to this research, we will not go into detail on it.
First, the user can directly modify the course content if the user has permission to perform this action.
The second option is creating annotations on the topic.
This allows the user to attach private or public notes to specific content on the topic.
Annotations are stored in the relational database, in the \texttt{Annotation} entity.
The entity contains a logical pointer to the annotated content.

The final possibility to integrate user content into a topic is by adding comments.
In contrast to annotations, comments have a typical structure.
They can take the form of questions, notes, suggestions, and can also be nested - which allows simple interaction and conversation between multiple users, and effectively enables dialogue between students and teachers.

The intention of this thesis is to use the NoSQL data storage as storage mechanism for the Recent Activity feed.
This entails that the authoritative information will not be stored in that data store, but rather be extracted from the relational database whenever an activity event is generated.
Accordingly, some information may be omitted from this data store, while other information is copied.

Consider the following domain description structured as activity events in the Recent Activity feed.
These events are items that a user may typically encounter in the web application as part of the feed.

``
\textbf{\underline{John}} created \textbf{\underline{Topic A}}.
''

``
\textbf{\underline{Jane}} commented on \textbf{\underline{Topic B}}:
\textit{This is not a good example. Try and find a better one.}}
''

``
\textbf{\underline{John}} commented on \textbf{\underline{Jane}'s comment} on \underline{Topic B}:
\textit{I agree.}}
''

``
\textbf{\underline{Jane}} annotated \textbf{\underline{Topic A}}.
''

``
\textbf{\underline{Bob}} updated \textbf{\underline{Topic B}}.
''

``
\textbf{\underline{Bob}} reacted to \textbf{\underline{John}'s comment} on \underline{Topic B}.
''

From this description we can already derive some requirements to take into account when designing the data models.
Every event has a structure characterised by three aspects.
First, there is a user at the base of the action, and in the descriptions this is the subject of every sentence.
Second, the subject performs an action, and the actions are limited to a certain subset as determined by the developer.
Third, the user operates on an object, which is usually but not always a topic.

In the activity events, the underlined text fragments represent hyperlinks in the web application to the relevant entities.
A hyperlink for a user may link to the profile page of the user, or the contributions of the respective user on the relevant topic.
Similarly, a hyperlink for a topic may link to a page that presents an overview of the topic, or directly to course content inside the topic.
The actual destination is up to the developers of the platform, and is not directly relevant for this research.
However, the existence of these hyperlinks entails that every aspect previously described has to consist of at least one attribute that is used in the hyperlinks -- most likely this will be the unique identifier of the entity in question.\\

We present the following conventions and rules to be followed in all NoSQL data models.

\begin{itemize}
  \item The user of an activity is called the \textit{subject}
  \item The action of an activity is called the \textit{predicate}
  \item The predicate can be one of the following values:\\ \texttt{created}, \texttt{updated}, \texttt{renamed}, \texttt{commented\_on}, \texttt{annotated}, \texttt{reacted\_to}
  \item The object to which an action refers, is called the \textit{item}
  \item No additional attribute to facilitate hyperlinks will be included
\end{itemize}

Furthermore, since the data in the NoSQL data store is generated in function of the business-critical data in the platform, it is expected to be written to the database only once, and read many times.
This enables us to design data models where read performance is prioritized over write performance.
It is also important to note that the data is always queried in a reverse chronological way, since the Recent Activity feed displays the most recent events first.

Using this logical description of the domain, we can start to derive physical data models for the selected NoSQL data stores.

\section{Physical data model}
\label{sec:physical-data-model}

\subsection{Document-oriented data model}
\label{subsec:document-data-model}

% References (normalized) vs embedded collections (denormalized)
  % Normalized: when read performance outweighs data duplication, hierarchical data sets
  % Denormalized: "contains" relationship, one-to-many
% Document growth: small documents
% Atomicity on write document level: atomic dependencies stored in same document
% Sharding: on date?
% Indexes: inexpensive because write once
% Data expiration/TTL: can't use

% Capped collections

% Inclusion of data: outdated data sometimes

% Step 1. Normalized or denormalized?
% Embedded collections (denormalized) -> better read performance but a bit of data duplicated
% References (normalized) -> Smaller documents, but gain is very small since only a few fields get duplicated (typically only display_name)
% Document stores prefer flat structure, or not linked that much

% Step 2. See links, find entities
% event -> subject
% event -> topic (object)
% event -> comment (object)
% comment -> subject
% comment -> topic
% event: predicate
% event: text (comment/annotation?)
% event: reaction

% Step 3. Normalized data model + example JSON
% Step 4. Convert normalized -> denormalized by embedding as much documents as possible
% entrypoints queries: event, topic
%   not user: selecting only by user activity is not nice, and embedding user is not a lot of information
% event embeds subject
% comment embeds subject
% event never embeds object, because it might point to embedded object (comment) or other collection (topic). So object always has to be a reference.
% event always has reference to topic

% https://community.toadworld.com/platforms/nosql/w/wiki/350.mongodb-schema-design

% Hoberman (2014): five heuristics for embedding or referencing

% Step 5. Denormalized data model + example JSON
% Step 6. Implement in Ruby

Document data stores provide a number of different approaches to storing linked data.
We attempt to cover the different methods, discussing common approaches and trade offs for each option.
In general, data can be linked in two different ways.

\begin{enumerate}
  \item Embedded collections (denormalized data).
        Embedding of data stores information in a single document.
        This technique is commonly used when the entity \textit{contains} the embedded entity: for example storing contact details of a user.
        Another use for this approach is storing one-to-many relationships, where the child documents are always queried within the context of the parent document.
  \item References (normalized data): Storing a reference to another document, similar to storing keys to other tables in the relational model.

\end{enumerate}

\subsection{Column-oriented data model}
\label{subsec:column-data-model}

\subsection{Graph-oriented data model}
\label{subsec:graph-data-model}

Using the examples of activity events in \cref{sec:domain-description}, we can identify the components used in database graph model.
The first entity that is identified are the \textit{nodes}

%% Nodes

% User, Annotation, Topic, Comment

%% Labels

% Subject, Object

%% Relations

% Event
% Comment->User, Comment->Topic due to the nodes inherent referent nature

% Assumptions: cannot create nested comments for more than 2 levels
% Comments on topics are not instantiated
% Comments on other comments => other comment is instantiated
% No data duplication, because 'other comment's  text is not even in entity :D

From the domain description, we can derive the labels, nodes and relationships to build the graph data model.
The first entities that are identified are the nodes.
In the domain, we have four main entities.

\begin{itemize}
  \item \texttt{User}
  \item \texttt{Topic}
  \item \texttt{Comment}
  \item \texttt{Annotation}
\end{itemize}

In order for the Recent Activity feed to string all this together, there is also an entity to represent an activity event called \texttt{Event}.
\texttt{Event}s have relationships to all other entities according to the (subject, predicate, object)-triple explained in \cref{sec:logical-data-model}.

% Labels
Neoj data modeling supports something called \textit{Labels}, a graph construct that groups nodes into sets.
A set contains nodes with the same label.
A node can have any number of labels.

In the domain model, we can distinguish one case where labels are very useful.
The \textit{object} of the event triple can be one of multiple entities, in this thesis the scope is restricted to \texttt{Topic}, \texttt{Comment} and \texttt{Annotation}.
Using this label abstraction allows future expansion with more object entity types.
Consequently, we propose the label \texttt{Object} which aggregates nodes of these types.
To keep the naming in the data model consistent, the lable \texttt{Subject} will also be applied to nodes of the type \texttt{User}.

% Relationships
We can identify the following interactions between the entities:

\begin{itemize}
  \item A \texttt{User} is the author of many \texttt{Topic}s
  \item A \texttt{Topic} has many \texttt{Comment}s attached to it
  \item A \texttt{Topic} has many \texttt{Annotation}s attached to it
  \item Both \texttt{Comment}s and \texttt{Annotation}s are created by a \texttt{User}
  \item A \texttt{Comment} optionally has many children comments
\end{itemize}

Additionally, the \texttt{Event} entity introduces the following interactions:

\begin{itemize}
  \item An \texttt{Event} relates to a \texttt{User} (the subject)
  \item An \texttt{Event} relates to an object
\end{itemize}

This leads us to the graph model in figure \ref{fig:graph-model}.

\section{Reference queries}
\label{sec:reference-queries}

% Concurrent queries pls

In order to perform a quantitative analysis on the selected data stores and the proposed physical data models, we present \TODO{five} reference queries in this chapter.
These reference queries will reflect the method of querying that is assumed to be the most common in the physical platform implementation, and mirrors the way data is queried from a database perspective.
All reference queries will be implemented using the available language bindings, however the generated implementation-specific query will also be presented.

Since the data of the use case is aimed at a write-once, read-many character, the majority of queries will not touch the data itself but merely read it.
We will present \TODO{four} queries that only request data, and \TODO{one} query that will insert new data into the data store.

\subsection{Querying}
\label{subsec:querying}

\subsubsection{Query 1}
\label{subsubsec:query-1}

``
Select N most recent events, ordered reverse chronologically
''

This query, as most simple reference query presented, is an example of a query that can be used on the homepage of the platform.
% TODO: Github reference
When a user opens the web application, a reverse chronologically ordered list of events is presented, much like how the activity feed on the Github platform is structured.
This view allows for a quick overview of the activity in the platform, and since the user is not signed in yet, it is not tailored.
This also means that everyone who visits the platform without signing in will receive the same events in their Recent Activity feed.

\subsubsection*{MongoDB}
\subsubsection*{CouchDB}
\subsubsection*{Neo4j}

\subsubsection{Query 2}
\label{subsubsec:query-2}

``
Select N most recent events, where the event is related to a topic in a list of given topics, ordered reverse chronologically
''

As mentioned in chapter \TODO{??}, a user also has to ability to subscribe to topics.
Once the user logs in to the platform, the Recent Activity feed can be presented in a more attractive way.
The events in the feed will then consist of only events related to topics the user has subscribed to (which also includes the topics where the user is author or contributor).

\subsubsection*{MongoDB}
\subsubsection*{CouchDB}
\subsubsection*{Neo4j}

\subsubsection{Query 3}
\label{subsubsec:query-3}

``
Select N most recent events, where the event is related to a given topic, ordered reverse chronologically
''

Every topic also has an overview page, which mainly contains metadata such as description, author, contributors and other information not directly related to the course content.
Next to the metadata, a custom Recent Activity feed is also included on the page.
This feed only contains events related to the topic the user is currently viewing, and effectively presents a timeline of changes and discussions.

\subsubsection*{MongoDB}
\subsubsection*{CouchDB}
\subsubsection*{Neo4j}

\subsubsection{Query 4}
\label{subsubsec:query-4}

``
Select N most recent events, where the event is related to a given user, ordered reverse chronologically
''

Similarly to topics, a user's profile page also includes a timeline of \TODO{his/her} activities: additions, deletions, comments and annotations that were recently made by that user.

\subsubsection*{MongoDB}
\subsubsection*{CouchDB}
\subsubsection*{Neo4j}

\subsection{Insertion}
\label{subsec:insertion}

\subsubsection{Query 5}
\label{subsubsec:query-5}

``
Insert N given :created or :updated events
''

Finally, since read requests will most likely outnumber write requests with several magnitudes in the studied use case, only one query where data is inserted is presented.
The query creates a single event in the data store.

\subsubsection*{MongoDB}
\subsubsection*{CouchDB}
\subsubsection*{Neo4j}

% TODO: Explain what ORMs are available

\section{Conclusion}
\label{sec:data-model-conclusion}

In this chapter we presented an introduction to the domain, and provided some examples of events in the Recent Activity feed.
Futhermore, we analyzed this domain description, and derived a logical data model for both document- and graph-oriented data stores.
Next, we proposed an implementation of this logical data model for two document-oriented, and one graph-oriented data store in the Ruby language bindings available for the respective database management systems.
Finally, we presented five reference queries for the three data stores, and included both a language binding-specific DSL and a physical query implementation for each.

% TODO: Conclusion about ORMs
